\chapter{Implementation}
\label{chp:impl}

This chapter explains the design and implementation of the application and the choices made during the development.

\section{Architecture}
The objective of the project is to send an image, compressed and not compressed, from one mote to another. To do this two PCs and two TelosB motes has been used, one sender mote and one receiver mote. The architecture of the system is shown in Figure \ref{fig:SystemOverview}. \emph{PC1} contains two classes to handle the image and send it. Before the image is ready to be send, it has to be converted from a bitmap to a byte array, and then it is ready be send via the serial communication. When it is transfered to \emph{Mote1} the serial communication interface on \emph{Mote1} is used. The image is stored in the flash storage, because it is to big to be stored in the ram or cache. From the flash it is compressed and sent to \emph{Mote2}, via the radio communication interface.

\myFigure{SystemOverview}{The architecture of the system}{fig:SystemOverview}{0.7}

As seen in the Figure all the classes and interfaces are also used in \emph{Mote2} and \emph{PC2}. The compressed data is received in \emph{Mote2}, then decompressed and stored in the flash. From the flash it is send to \emph{PC2} via serial communication. 

The image which is send around is only the raster of the original BMP. The header and footer has been stripped before it is send to a TelosB. When a PC receives the image back from a TelosB the image is then reconstructed according to its original.

\section{Serial communication}
The serial communication is used to pass the image from the PC to the TelosB mote. when the image has been passed, it will be stored in the external flash memory of the TelosB. When the image has been transferred between the TelosB's the serial communication was used to send the image back to the PC. On the PC the image is reconstructed and the image is saved on the PC.

To enable serial communication on the TelosB an interface for serial communication was created. This interface gave access to the serial communication features. 

Before the image was transferred from either the PC or the TelosB the image was divided into packages of 64 bytes. The intended receiver kept waiting for packages until the sender signals it is the last package the receiver is receiving. Then the receiver will stop the process of receiving packages. 

Everytime a package is received on a TelosB the 64 bytes of the image is written to the flash. When a package is received on a PC the 64 bytes of the image is stored in an array. 


\section{Flash storage}

When transferring an image from the pc to the TelosB, the external flash storage is required. The reason for this requirement is the size of the image. To fulfill this requirement the Block storage is used. The Block storage is ideal for storing large objects that cannot fit into the RAM like the image.

The Block storage is a write-once model of storage. Rewriting requires an erase. Rewriting is required in this project as the image needs to be transfered with different compression/decompressions and therefor new data needs to be written to the flash.

To be able to use the Block storage the flash chip needs to be divided into one or more fixed-sized volumes. The volume is specified at compile-time. The volume size used in this project is 65536 which is the maximum size we could reach in one volume.

An interface named \emph{Flash} which is seen in Listing \ref{lst:flash}. Flash was created to accommodate the \emph{Sender} and the \emph{Receiver} which both needs to be able to write and read from the flash. 

\begin{lstlisting}[caption={The interface flash}, label=lst:flash]
interface Flash
{
	command error_t write(uint8_t* data, uint32_t addr, uint8_t size);
	command error_t read(uint8_t* data, uint32_t addr, uint8_t size);
	command error_t sync();
	command error_t erase();
	event void readDone(error_t result, storage_len_t len);
	event void writeDone(error_t result);
	event void syncDone(error_t result);
	event void eraseDone(error_t result);	
}
\end{lstlisting}

The implementation of write requires three parameters. The first parameter is the data which should be written to the flash. The second parameter is the address which it should start the write at. The third parameter is the length of the data. 

The implementation of read is like the implementation of write. The difference between them is the first parameter is an array where the ridden data is placed in. 

Other commands like sync and erase is also implemented. the command sync is used to finalize writes to the volume. The sync operation must be issued to ensure the data is stored in a non-volatile storage. 

The interface also includes events for all the commands. 

\section{Image Compression}
A lossy compression is chosen because it is normal when working with images, and it is fairly simple. The first compression that was implemented was a lossy compression which removed every eight bit. This was done by:

\section{Radio communication}
To enable communication between the TelosB’s, radio communication is used. The radio communication was used for transferring an image form one TelosB to another TelosB. Before each transferon the \emph{Sender} side, the image has been reed in chunks of 1024 bytes. The chunk of 1024 bytes is loaded into a buffer. The buffer is then divided into packages of 64 bytes and then sent to the receiving TelosB. The sequence diagram in Figure \ref{fig:radioCom} gives an overview of how this process works.

LINK TIL AT RETTE I DIAGRAMMET FJERN DENNE NÅR I ER FÆRDIGE \url{https://drive.google.com/file/d/0Bw37nIXex8aXZTlxSWlfeWU2UjA/view?usp=sharing}

\myFigure{MoteToMoteCom}{TelosB to TelosB radio communication sequence diagram}{fig:radioCom}{0.9}

\FloatBarrier

The sequence diagram in Figure \ref{fig:radioCom} is an example of a non-compressed image which is then transferred to a receiver. If the image has been compressed it will send the packages corresponding to the compressed size. For example, if the image has been compressed with a 4-bit compression the 1024 bytes will be reduced to 512 bytes. So instead of sending 16 packages the \emph{Sender} sends 8 packages of 64 bytes each.

When the \emph{Sender} has send 16 packages with 64 bytes in each. Then the \emph{Sender} waits for a \emph{TRANSFER\_ACK } from the \emph{Receiver}. The \emph{Recevier} sends the \emph{TRANSFER\_ACK } to signal that the \emph{Receiver} is ready to receive 16 new packages. When the \emph{Sender} receives the \emph{TRANSFER\_ACK } the \emph{Sender} will read the next chunk of 1024 bytes and put it into the buffer.

When the last package of the image is about to be send the \emph{Sender} sends a \emph{TRANSFER\_DONE} with the last package. The \emph{Receiver} will not send any \emph{TRANSFER\_ACK} back and the \emph{Sender} will neither expect a \emph{TRANSFER\_ACK }.

Each time the \emph{Receiver} receives a package of 64 bytes it stores the image in a buffer. The buffer is of the size of 1024 bytes. When the buffer is full the \emph{Receiver} takes the buffer and writes all the bytes into the external flash. If a compression is applied the buffer will be decompressed before writing to the flash.

For the \emph{Sender} to signal that a compression has been applied to the image. The \emph{Sender} applies the information to the header. The \emph{Receiver} then do the necessary actions to the image.