\chapter{Implementation}
\label{chp:impl}

This chapter explains the design and implementation of the application and the choices made during the development.

\section{Architecture}
The objective of the project is to send an image, compressed and not compressed, from one mote to another. To do this two PCs and two TelosB motes has been used, one sender mote and one receiver mote. The architecture of the system is shown in figure \ref{fig:SystemOverview}. \emph{PC1} contains two classes to handle the image and send it. Before the image is ready to be send, it has to be converted from bitmap to binary array, and then it is ready sent via the serial communication. When it is transfered to \emph{Mote1} the serial communication class on \emph{Mote1} is used. The image is stored in the flash storage, because it is to big to be stored in the ram or cache. From the flash it is compressed and sent to \emph{Mote2}, via the radio communication class.

\myFigure{SystemOverview}{The architecture of the system.}{fig:SystemOverview}{0.7}

As seen in the figure all the classes are again used in \emph{Mote2} and \emph{PC2}. The compressed data is received in \emph{Mote2}, decompressed and stored in the flash. From the flash it is sent to the \emph{PC2} via the serial communication. 

\section{Serial communication}
The serial communication is used to pass the image from the PC to the TelosB mote. when the image has been passed, it will be stored in the flash memory of the TelosB. Both the PC and the mote has a class called serial communication, which handles the passing of the image.

\section{Flash storage}

When transferring an image from the pc to the TelosB, the external flash storage is required. The reason for this requirement is the size of the image. To fulfill this requirement the Block storage is used. The Block storage is ideal for storing large objects that cannot fit into the RAM like the image.

The Block storage is a write-once model of storage. Rewriting requires an erase. Rewriting is required in this project as the image needs to be transfered with different compression/decompressions and therefor new data needs to be written to the flash.

To be able to use the Block storage the flash chip needs to be divided into one or more fixed-sized volumes. The volume is specified at compile-time. The volume size used in this project is 65536 which is the maximum size we could reach in one volume.

An interface named \emph{Flash} \ref{lst:flash} was created to accommodate the \emph{Sender} and the \emph{Receiver} which both needs to be able to write and read from the flash. 

\begin{lstlisting}[caption={The interface flash}, label=lst:flash]
interface Flash
{
	command error_t write(uint8_t* data, uint32_t addr, uint8_t size);
	command error_t read(uint8_t* data, uint32_t addr, uint8_t size);
	command error_t sync();
	command error_t erase();
	event void readDone(error_t result, storage_len_t len);
	event void writeDone(error_t result);
	event void syncDone(error_t result);
	event void eraseDone(error_t result);	
}
\end{lstlisting}

The implementation of write requires three parameters. The first parameter is the data which should be written to the flash. The second parameter is the address which it should start the write at. The third parameter is the length of the data. 

The implementation of read is like the implementation of write. The difference between them is the first parameter is an array where the ridden data is placed in. 

Other commands like sync and erase is also implemented. the command sync is used to finalize writes to the volume. The sync operation must be issued to ensure the data is stored in a non-volatile storage. 

The interface also includes events for all the commands. 

\section{Image Compression}
A lossy compression is chosen because it is normal when working with images, and it is fairly simple. The first compression that was implemented was a lossy compression which removed every eight bit. This was done by:

\section{Radio communication}
The radio communication is splitted up in two different parts. The sender and the receiver.

\subsection{Sender}
The radio communication was established with the use of a button on the TelosB. This is done so that the 
user can start the transfer manual. When the button is clicked, the function \emph{Flash.read()} is executed. This functions takes three parameters

\begin{lstlisting}[caption={The function Flash.read}, label=lst:fread]
call Flash.read(readArray,0, SIZE+(bytesToRemove*8));
\end{lstlisting}

All the data is packed from \emph{readArray} into a data package. Now the package is ready to be sent, this is done by calling \emph{AMSend.send()}. This runs the function \emph{AMSend.sendDone()}. Here it is checked, if there is more data to be sent, if there is, the \emph{Flash.read()} is called again, until all data is sent. 

\begin{lstlisting}[caption={the function Flash.ReadDone}, label=lst:freaddone]
event void Flash.readDone(error_t result)
{	
	int i = 0;
	uint8_t status = 0;		
	readPacketCounter++;	
	if (result != SUCCESS)
	{
		call Leds.led0On();
	}		
	
	printf("Value: %u\n",
	Round(((packetCounter*SIZE)/(SIZE+(bytesToRemove*8)))));
	printfflush();
	if(readPacketCounter >=
	Round(((packetCounter*SIZE)/(SIZE+(bytesToRemove*8)))))
	{
		status = 1;
		call Leds.led1On();
		call Leds.led2On();
		printf("Sending last package\n");
		printf("ReadPacketCounter %u\n", readPacketCounter);
		printfflush();
	}
	
	if (!busy) 
	{
		test_serial_msg_t* btrpkt = (test_serial_msg_t*)
			(call Packet.getPayload(&pkt, sizeof (test_serial_msg_t)));
		btrpkt->status = status;
		btrpkt->bytesRemoved = bytesToRemove;
		btrpkt->diff = packageDiff;
		if(bytesToRemove == 1)
		{
			uint8_t* compressedImage;
			printf("Compressing data\n");
			printfflush();
			call Compression.compress(readArray, compressedImage);
			printf("Done Compressing data\n");
			printfflush();
			
			for(i=0; i < SIZE; i++)
			{
			btrpkt->image[i] = compressedImage[i];
			}
		
		}
		else
		{
			printf("Packaging data\n");
			printfflush();
			for(i=0; i < SIZE; i++)
			{
			
			btrpkt->image[i] = readArray[i];   	
			}	
		}
		
		if (call AMSend.send(AM_BROADCAST_ADDR, &pkt,
		sizeof(test_serial_msg_t)) == SUCCESS) 
		{
			busy = TRUE;
		}
		else
		{
			//call Leds.led0On();
		}
	}
	//call Leds.led2Toggle();
}
\end{lstlisting}

\begin{lstlisting}[caption={the function AMSend.sendDone}, label=lst:]
event void AMSend.sendDone(message_t *msg, error_t error)
{
	if(receiving == TRUE)
		return;
	
	busy = FALSE;
	
	if(readPacketCounter < 
		Round(((packetCounter*SIZE)/(SIZE+(bytesToRemove*8)))))
	{	
		call Flash.read(readArray, 
		readPacketCounter*SIZE+(bytesToRemove*8),
		SIZE+(bytesToRemove*8));
	}
}
\end{lstlisting}

\subsection{Receiver}
To receive an image on a TelosB the \emph{receive()} function is developed in TestSerial.nc. Receive i shown in listing \ref{lst:receive}. It takes three parameters, a message, a payload, and lenght. At first it tests if the size of the message is the same as the lenght. As it receives the data, it checks if all data is sent. if status is '1' the data is received. When each package is received, it is checked if it has been compressed, by eksamining if any bytes have been removed. If it is so, then it will be decompressed. if not, it will be loaded into the flash memory.

\begin{lstlisting}[label=lst:receive, caption=Receive function in TestSerialC.nc]
event message_t * Receive.receive(message_t *msg, void *payload,
uint8_t len){
	uint8_t* imageForFlashWrite;
	call Leds.led0Toggle();
	if (len != sizeof(test_serial_msg_t)) 
	{
		return msg;
	}
	else 
	{ 	     
		test_serial_msg_t* rcm = (test_serial_msg_t*)payload;
		receiving = TRUE;
		if(rcm->status == 1)
		{
			call Leds.led2On();			
			receiving = FALSE;
			packageDiff = rcm->diff;
		}
		
		if(rcm->bytesRemoved > 0)
		{
			imageForFlashWrite = call Compression.decompress(rcm->image,
				(SIZE+(rcm->bytesRemoved*SIZE)));
		}
		else
		{
			imageForFlashWrite = rcm->image;
		}
		
		call Flash.write(imageForFlashWrite, addr);
		addr = addr + SIZE;
		packetCounter++;
	}
	return msg;
}
\end{lstlisting}