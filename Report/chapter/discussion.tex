\chapter{Discussion}
\label{chp:disc}

In this chapter the implementation and test decisions will be discussed. 

In the application, Bresenham’s line algorithm was used for drawing a line. This algorithm is not able to draw vertical lines only slopes. This was solved by adding functionality to the algorithm so it could draw this. In the first implementation of the algorithm it could not handle lines where the x value of the second point was greater than the x value in the first point. This was solve by checking the two values, and switch them, if the x value of the second point was greatest.

At the start all functions was implemented with classic recursion. This led to some functions causing stack overflow. to resolve tail recursion was used. This turn out in an effective way. The reason for this, is that tail recursion allows the compiler to optimize and avoid to allocate a new stack frame for each recursive call. 

It was chosen not to keep the bounding-box state in Scheme, because it would violate the basic principles of functional programming. By not saving the state of the bounding-box in scheme it was insured that the scheme code had no side effects. Instead the state of the bounding box was saved in C\#. An alternative option could have been to compromise and use the \emph{set!} operator to save the state of the bounding-box in scheme.

Furthermore all the code that was written was unit tested. When implementing the unit tests it was important to ensure all boundary cases were tested. When unit testing the line function in scheme eight unit tests were implemented to test different boundary cases. These cases included a vertical line up and down, horizontal line up and down and lines in the range 1-89, 91-179, 181-269 and 271-359 degrees. When testing it was checked that the function returned the expected result. Errors in the implementation was found in the line function when testing all boundaries. The unit tests could generally be considered a success as they helped identifying bugs and made sure the source code had the correct behaviour.

It was likewise a possibility to do an integration test of the complete system but it was chosen not to do this as the complete system was quite small. Integrations tests could have been created in C\# by using the concrete implementation instead of mocks.

For the rendering of the coordinates which the scheme code yielded a canvas was used. The canvas worked well together with the MVVM structure of the WPF application. When the fill functionality was added the speed of the rendering onto the canvas was not satisfactory. A decision was made to use a bitmap instead and examine the speed of it. The result revealed the bitmap as the fastest to render the coordinates. Thereby the bitmap replaced the canvas. 

%Måske mere konklusion ( det neden under..)
In general scheme as a programming language and the functional paradigm has shown how it can facilitate very fast calculation and impressive optimization using tail recursion. Furthermore creating stateless function can be seen as a huge advantage in numerous projects especially concurrent systems were state variables can be very complex. Combining a functional language with a imperative language made it easier to keep state for the user interface and the two languages together has proven as a strong combination.