\chapter{Implementation} 
\label{chp:impl}

This chapter explains the design and implementation of the application and the choices made during the development.

\section{Multi paradigm}
The application uses the functional programming language Scheme together with the imperative language C\#. This is done by using \emph{IronScheme} which is an implementation of Scheme that targets .NET. This allows to call Scheme functions directly from C\# code and hence combine the use of the two languages.

\section{User interface in C\# WPF}
C\# and WPF was used for developing the graphical user interface. This made it possible to create the required interface that allowed the user to draw on a bitmap.

This was done using Model-View-ViewModel(MVVM) architecture to separate the graphical user interface from the business logic. This was done using the MVVM CaliburnMicro framework. Using MVVM ensured that the business logic was very loosely coupled with the view through data-binding and therefore easier to test. The is illustrated in figure \ref{fig:mvvm}

\myFigure{mvvm.png}{Mode-View-ViewModel}{fig:mvvm}{1} 

A class diagram shown on figure \ref{fig:class} illustrates the essential design and classes used. The ShellView presents the content for the user and is updated through data-binding by the ShellViewModel. ShellViewModel depends on the two interfaces IShemeHandler and IBitmapDrawing. By only depending on interfaces testability is ensured as mocks can be used instead concrete implementations. 

The SchemeHandler is a class that handles the evaluation of the scheme code by using IronScheme. BitmapDrawing is used for drawing single pixels and text on the bitmap.

\myFigure{class.png}{UML class diagram}{fig:class}{0.6} 

\section{Drawing Engine in Scheme}
Scheme was used for developing the drawing engine. This allowed for fast and stateless computation of the graphics being shown in the user interface. 

For drawing lines in the application the Bresenhamâ€™s line algorithm was used. This algorithm can draw a line between two points. The circle Midpoint algorithm was used for drawing circles. The implementation of the circle function is shown in listing \ref{lst:circle}. The function takes three parameters, the center coordinates and the radius. First x, y and d is created. \emph{x} is defined as 0, and are used as a counter \emph{y} is a copy of r, and is used in the algorithm calculations. Final \emph{d} is  a decision parameter and decides the calucation of paramters of the recursive call. The stop condition is when \emph{x} is bigger than \emph{y}, then the the last element \emph{'()} is returned at the list composed and returned.

The circle function is implemented with classic recursion. Tail recursion could also have been used but in this case classic recursion was sufficient. If the circles instead had to be drawn on a bigger bitmap the classic recursive calls could lead to stack overflow.


\begin{lstlisting}[caption={Scheme function circle}, label=lst:circle]
(define (circle centerX centerY r)
(let((x 0) (y r) (d (/ (- 5 (* r 4)) 4)))
(letrec ((GetCircleCoor (lambda (x y r d)
(if (<= x y)
(if (< d 0)    
(cons (+ centerX x) (cons (+ centerY y)                                                
(cons (- centerX x) (cons (+ centerY y)
(cons (+ centerX x) (cons (- centerY y)         
(cons (- centerX x) (cons (- centerY y)
(cons (+ centerX y) (cons (+ centerY x)
(cons (- centerX y) (cons (+ centerY x)
(cons (+ centerX y) (cons (- centerY x)
(cons (- centerX y) (cons (- centerY x)  
(GetCircleCoor (+ x 1) y r (+ d (+ (* x 2) 1)))))))))))))))))))
(cons (+ centerX x) (cons (+ centerY y)                                                
(cons (- centerX x) (cons (+ centerY y)
(cons (+ centerX x) (cons (- centerY y)         
(cons (- centerX x) (cons (- centerY y)
(cons (+ centerX y) (cons (+ centerY x)
(cons (- centerX y) (cons (+ centerY x)
(cons (+ centerX y) (cons (- centerY x)
(cons (- centerX y) (cons (- centerY x)  
(GetCircleCoor (+ x 1) (- y 1) r (+ d (+ (* 2 (- x y)) 1))))))))))))))))))))
'() ))))
(GetCircleCoor x y r d))))   
\end{lstlisting}

A function where tail recursion was required is the implemented function \emph{fill}. Which is a function that can fill an object with a color in the application. The difference between classic and tail recursion is
\begin{itemize}
	\item[--] \textbf{Classic recursion} makes the recursive calls before the actual processing
	\item[--] \textbf{Tail recursion} does the processing before the recursive call.  
\end{itemize}

fill was first created with classic recursion but this gave a stack overflow as two many function calls were made. Instead tail recursion was used so that the compiler could optimize this function and avoid stack overflow.  This is because the scheme compiler is able to very effectively optimize tail recursion compared to classic recursion.

\begin{lstlisting}[caption={Scheme function fill}, label=lst:fill]
(define (fill c g)
(letrec ((fillCoor (lambda(g x)
(if (or (or (null? g) (null? (cdr g)) (null? (cddr g))) (null? (cdddr g)))
(append x (cons c '()))
(fillCoor (cddddr g)
(append (line (car g)
(cadr g)
(car (cddr g))
(car (cdddr g))) x))
))))
(fillCoor g '())))
\end{lstlisting}

Furthermore the \emph{fill} function uses high order programming as functions are passed as parameters. 

The function is shown in listing \ref{lst:fill} and takes the parameters \emph{c} and \emph{g} where \emph{c} is the color and \emph{g} is a function that draws an object. It runs through the list that the function returns and uses the line algorithm to draw lines between two opposite coordinates. This implementation was chosen as it was simple approach to create a fill function even though some redundant coordinates might be included. 

Another function that uses high order programming is the draw function. The function was designed as a variadic function that takes a variable amount of other functions and combines them. The function can be called with a color but this is optional. The part where you can see the varidic parameter is shown 
in listing \ref{lst:draw}
 
\begin{lstlisting}[caption={Part of scheme function draw }, label=lst:draw]
(define (draw . g)
...
\end{lstlisting}